{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = getDirection;\n\nvar _functions = require(\"./functions\");\n/**\n * Checks the intended tip direction and falls back if not enough space\n */\n\n\nfunction checkLeftRightWidthSufficient(tip, target, distance, bodyPadding) {\n  var targetRect = target.getBoundingClientRect();\n  var deadSpace = Math.min(targetRect.left, document.documentElement.clientWidth - targetRect.right);\n  return tip.offsetWidth + target.offsetWidth + distance + bodyPadding + deadSpace < document.documentElement.clientWidth;\n}\n\nfunction checkTargetSufficientlyVisible(target, tip, props) {\n  var targetRect = target.getBoundingClientRect();\n  var bottomOverhang = targetRect.bottom > window.innerHeight;\n  var topOverhang = targetRect.top < 0; // if the target is taller than the viewport (and we know there's sufficient left/right width before this is called),\n  // then go with the left/right direction as top/bottom will both be off screen\n\n  if (topOverhang && bottomOverhang) {\n    return true;\n  } // if the target is bigger than the tip, we need to check if enough of the target is visible\n\n\n  if (target.offsetHeight > tip.offsetHeight) {\n    var halfTargetHeight = target.offsetHeight / 2;\n    var arrowClearance = props.arrowSize + _functions.minArrowPadding;\n    var bottomOverhangAmount = targetRect.bottom - window.innerHeight;\n    var topOverhangAmount = -targetRect.top;\n    var targetCenterToBottomOfWindow = halfTargetHeight - bottomOverhangAmount;\n    var targetCenterToTopOfWindow = halfTargetHeight - topOverhangAmount;\n    return targetCenterToBottomOfWindow >= arrowClearance && targetCenterToTopOfWindow >= arrowClearance;\n  } // otherwise just check that the whole target is visible\n\n\n  return !bottomOverhang && !topOverhang;\n}\n\nfunction checkForArrowOverhang(props, arrowStyles, bodyPadding) {\n  var scrollLeft = (0, _functions.getScrollLeft)();\n  var hasLeftClearance = arrowStyles.positionStyles.left - scrollLeft > bodyPadding;\n  var hasRightClearance = arrowStyles.positionStyles.left + props.arrowSize * 2 < scrollLeft + document.documentElement.clientWidth - bodyPadding;\n  return !hasLeftClearance || !hasRightClearance;\n}\n\nfunction getDirection(currentDirection, tip, target, props, bodyPadding, arrowStyles, recursive) {\n  // can't switch until target is rendered\n  if (!target) {\n    return currentDirection;\n  }\n\n  var targetRect = target.getBoundingClientRect();\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props); // this is how much space is needed to display the tip above or below the target\n\n  var heightOfTipWithArrow = tip.offsetHeight + arrowSpacing + bodyPadding;\n  var spaceBelowTarget = window.innerHeight - targetRect.bottom;\n  var spaceAboveTarget = targetRect.top;\n  var hasSpaceBelow = spaceBelowTarget >= heightOfTipWithArrow;\n  var hasSpaceAbove = spaceAboveTarget >= heightOfTipWithArrow;\n\n  switch (currentDirection) {\n    case 'right':\n      // if the window is not wide enough try top (which falls back to down)\n      if (!checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding) || !checkTargetSufficientlyVisible(target, tip, props)) {\n        return getDirection('up', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (document.documentElement.clientWidth - targetRect.right < tip.offsetWidth + arrowSpacing + bodyPadding) {\n        return 'left';\n      }\n\n      return 'right';\n\n    case 'left':\n      // if the window is not wide enough try top (which falls back to down)\n      if (!checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding) || !checkTargetSufficientlyVisible(target, tip, props)) {\n        return getDirection('up', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (targetRect.left < tip.offsetWidth + arrowSpacing + bodyPadding) {\n        return 'right';\n      }\n\n      return 'left';\n\n    case 'up':\n      if (!recursive && arrowStyles && checkForArrowOverhang(props, arrowStyles, bodyPadding)) {\n        return getDirection('left', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (!hasSpaceAbove) {\n        if (hasSpaceBelow) {\n          return 'down';\n        }\n\n        if (!recursive && checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding)) {\n          return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n        }\n      }\n\n      return 'up';\n\n    case 'down':\n    default:\n      if (!recursive && arrowStyles && checkForArrowOverhang(props, arrowStyles, bodyPadding)) {\n        return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (!hasSpaceBelow) {\n        // if there's no space below, but space above, switch to that direction\n        if (hasSpaceAbove) {\n          return 'up'; // if there's not space above or below, check if there would be space left or right\n        }\n\n        if (!recursive && checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding)) {\n          return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n        } // if there's no space in any direction, default to the original direction\n\n      }\n\n      return 'down';\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","getDirection","_functions","require","checkLeftRightWidthSufficient","tip","target","distance","bodyPadding","targetRect","getBoundingClientRect","deadSpace","Math","min","left","document","documentElement","clientWidth","right","offsetWidth","checkTargetSufficientlyVisible","props","bottomOverhang","bottom","window","innerHeight","topOverhang","top","offsetHeight","halfTargetHeight","arrowClearance","arrowSize","minArrowPadding","bottomOverhangAmount","topOverhangAmount","targetCenterToBottomOfWindow","targetCenterToTopOfWindow","checkForArrowOverhang","arrowStyles","scrollLeft","getScrollLeft","hasLeftClearance","positionStyles","hasRightClearance","currentDirection","recursive","arrowSpacing","getArrowSpacing","heightOfTipWithArrow","spaceBelowTarget","spaceAboveTarget","hasSpaceBelow","hasSpaceAbove"],"sources":["/home/umang7/Music/Ripik-Website/node_modules/react-tooltip-lite/dist/getDirection.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = getDirection;\n\nvar _functions = require(\"./functions\");\n\n/**\n * Checks the intended tip direction and falls back if not enough space\n */\nfunction checkLeftRightWidthSufficient(tip, target, distance, bodyPadding) {\n  var targetRect = target.getBoundingClientRect();\n  var deadSpace = Math.min(targetRect.left, document.documentElement.clientWidth - targetRect.right);\n  return tip.offsetWidth + target.offsetWidth + distance + bodyPadding + deadSpace < document.documentElement.clientWidth;\n}\n\nfunction checkTargetSufficientlyVisible(target, tip, props) {\n  var targetRect = target.getBoundingClientRect();\n  var bottomOverhang = targetRect.bottom > window.innerHeight;\n  var topOverhang = targetRect.top < 0; // if the target is taller than the viewport (and we know there's sufficient left/right width before this is called),\n  // then go with the left/right direction as top/bottom will both be off screen\n\n  if (topOverhang && bottomOverhang) {\n    return true;\n  } // if the target is bigger than the tip, we need to check if enough of the target is visible\n\n\n  if (target.offsetHeight > tip.offsetHeight) {\n    var halfTargetHeight = target.offsetHeight / 2;\n    var arrowClearance = props.arrowSize + _functions.minArrowPadding;\n    var bottomOverhangAmount = targetRect.bottom - window.innerHeight;\n    var topOverhangAmount = -targetRect.top;\n    var targetCenterToBottomOfWindow = halfTargetHeight - bottomOverhangAmount;\n    var targetCenterToTopOfWindow = halfTargetHeight - topOverhangAmount;\n    return targetCenterToBottomOfWindow >= arrowClearance && targetCenterToTopOfWindow >= arrowClearance;\n  } // otherwise just check that the whole target is visible\n\n\n  return !bottomOverhang && !topOverhang;\n}\n\nfunction checkForArrowOverhang(props, arrowStyles, bodyPadding) {\n  var scrollLeft = (0, _functions.getScrollLeft)();\n  var hasLeftClearance = arrowStyles.positionStyles.left - scrollLeft > bodyPadding;\n  var hasRightClearance = arrowStyles.positionStyles.left + props.arrowSize * 2 < scrollLeft + document.documentElement.clientWidth - bodyPadding;\n  return !hasLeftClearance || !hasRightClearance;\n}\n\nfunction getDirection(currentDirection, tip, target, props, bodyPadding, arrowStyles, recursive) {\n  // can't switch until target is rendered\n  if (!target) {\n    return currentDirection;\n  }\n\n  var targetRect = target.getBoundingClientRect();\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props); // this is how much space is needed to display the tip above or below the target\n\n  var heightOfTipWithArrow = tip.offsetHeight + arrowSpacing + bodyPadding;\n  var spaceBelowTarget = window.innerHeight - targetRect.bottom;\n  var spaceAboveTarget = targetRect.top;\n  var hasSpaceBelow = spaceBelowTarget >= heightOfTipWithArrow;\n  var hasSpaceAbove = spaceAboveTarget >= heightOfTipWithArrow;\n\n  switch (currentDirection) {\n    case 'right':\n      // if the window is not wide enough try top (which falls back to down)\n      if (!checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding) || !checkTargetSufficientlyVisible(target, tip, props)) {\n        return getDirection('up', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (document.documentElement.clientWidth - targetRect.right < tip.offsetWidth + arrowSpacing + bodyPadding) {\n        return 'left';\n      }\n\n      return 'right';\n\n    case 'left':\n      // if the window is not wide enough try top (which falls back to down)\n      if (!checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding) || !checkTargetSufficientlyVisible(target, tip, props)) {\n        return getDirection('up', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (targetRect.left < tip.offsetWidth + arrowSpacing + bodyPadding) {\n        return 'right';\n      }\n\n      return 'left';\n\n    case 'up':\n      if (!recursive && arrowStyles && checkForArrowOverhang(props, arrowStyles, bodyPadding)) {\n        return getDirection('left', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (!hasSpaceAbove) {\n        if (hasSpaceBelow) {\n          return 'down';\n        }\n\n        if (!recursive && checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding)) {\n          return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n        }\n      }\n\n      return 'up';\n\n    case 'down':\n    default:\n      if (!recursive && arrowStyles && checkForArrowOverhang(props, arrowStyles, bodyPadding)) {\n        return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n      }\n\n      if (!hasSpaceBelow) {\n        // if there's no space below, but space above, switch to that direction\n        if (hasSpaceAbove) {\n          return 'up'; // if there's not space above or below, check if there would be space left or right\n        }\n\n        if (!recursive && checkLeftRightWidthSufficient(tip, target, arrowSpacing, bodyPadding)) {\n          return getDirection('right', tip, target, arrowSpacing, bodyPadding, arrowStyles, true);\n        } // if there's no space in any direction, default to the original direction\n\n      }\n\n      return 'down';\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}