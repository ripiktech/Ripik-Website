{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = positions;\n\nvar _getDirection = _interopRequireDefault(require(\"./getDirection\"));\n\nvar _functions = require(\"./functions\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * Sets tip max width safely for mobile\n */\n\n\nfunction getTipMaxWidth() {\n  return typeof document !== 'undefined' ? document.documentElement.clientWidth - _functions.bodyPadding * 2 : 1000;\n}\n/**\n * Parses align mode from direction if specified with hyphen, defaulting to middle if not -\n * e.g. 'left-start' is mode 'start' and 'left' would be the default of 'middle'\n */\n\n\nfunction parseAlignMode(direction) {\n  var directionArray = direction.split('-');\n\n  if (directionArray.length > 1) {\n    return directionArray[1];\n  }\n\n  return 'middle';\n}\n/**\n * Gets wrapper's left position for top/bottom tooltips as well as needed width restriction\n */\n\n\nfunction getUpDownPosition(tip, target, state, direction, alignMode, props) {\n  var left = -10000000;\n  var top;\n  var transform = state.showTip ? undefined : 'translateX(-10000000px)';\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n\n  if (tip) {\n    // get wrapper left position\n    var scrollLeft = (0, _functions.getScrollLeft)();\n    var targetRect = target.getBoundingClientRect();\n    var targetLeft = targetRect.left + scrollLeft;\n    var halfTargetWidth = Math.round(target.offsetWidth / 2);\n    var tipWidth = Math.min(getTipMaxWidth(), tip.offsetWidth);\n    var arrowCenter = targetLeft + halfTargetWidth;\n    var arrowLeft = arrowCenter - props.arrowSize;\n    var arrowRight = arrowCenter + props.arrowSize;\n\n    if (alignMode === 'start') {\n      left = props.arrow ? Math.min(arrowLeft, targetLeft) : targetLeft;\n    } else if (alignMode === 'end') {\n      var rightWithArrow = Math.max(arrowRight, targetLeft + target.offsetWidth);\n      var rightEdge = props.arrow ? rightWithArrow : targetLeft + target.offsetWidth;\n      left = Math.max(rightEdge - tipWidth, _functions.bodyPadding + scrollLeft);\n    } else {\n      var centeredLeft = targetLeft + halfTargetWidth - Math.round(tipWidth / 2);\n      var availableSpaceOnLeft = _functions.bodyPadding + scrollLeft;\n      left = Math.max(centeredLeft, availableSpaceOnLeft);\n    } // check for right overhang\n\n\n    var rightOfTip = left + tipWidth;\n    var rightOfScreen = scrollLeft + document.documentElement.clientWidth - _functions.bodyPadding;\n    var rightOverhang = rightOfTip - rightOfScreen;\n\n    if (rightOverhang > 0) {\n      left -= rightOverhang;\n    }\n\n    if (direction === 'up') {\n      top = targetRect.top + (0, _functions.getScrollTop)() - (tip.offsetHeight + arrowSpacing);\n    } else {\n      top = targetRect.bottom + (0, _functions.getScrollTop)() + arrowSpacing;\n    }\n  }\n\n  return {\n    left: left,\n    top: top,\n    transform: transform\n  };\n}\n/**\n * gets top position for left/right arrows\n */\n\n\nfunction getLeftRightPosition(tip, target, state, direction, alignMode, props) {\n  var left = -10000000;\n  var top = 0;\n  var transform = state.showTip ? undefined : 'translateX(-10000000px)';\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n  var arrowPadding = props.arrow ? _functions.minArrowPadding : 0;\n\n  if (tip) {\n    var scrollTop = (0, _functions.getScrollTop)();\n    var scrollLeft = (0, _functions.getScrollLeft)();\n    var targetRect = target.getBoundingClientRect();\n    var targetTop = targetRect.top + scrollTop;\n    var halfTargetHeight = Math.round(target.offsetHeight / 2);\n    var arrowTop = targetTop + halfTargetHeight - props.arrowSize;\n    var arrowBottom = targetRect.top + scrollTop + halfTargetHeight + props.arrowSize; // TODO: handle close to edges better\n\n    if (alignMode === 'start') {\n      top = props.arrow ? Math.min(targetTop, arrowTop) : targetTop;\n    } else if (alignMode === 'end') {\n      var topForBottomAlign = targetRect.bottom + scrollTop - tip.offsetHeight;\n      top = props.arrow ? Math.max(topForBottomAlign, arrowBottom - tip.offsetHeight) : topForBottomAlign;\n    } else {\n      // default to middle, but don't go below body\n      var centeredTop = Math.max(targetTop + halfTargetHeight - Math.round(tip.offsetHeight / 2), _functions.bodyPadding + scrollTop); // make sure it doesn't go below the arrow\n\n      top = Math.min(centeredTop, arrowTop - arrowPadding);\n    } // check for bottom overhang\n\n\n    var bottomOverhang = top - scrollTop + tip.offsetHeight + _functions.bodyPadding - window.innerHeight;\n\n    if (bottomOverhang > 0) {\n      // try to add the body padding below the tip, but don't offset too far from the arrow\n      top = Math.max(top - bottomOverhang, arrowBottom + arrowPadding - tip.offsetHeight);\n    }\n\n    if (direction === 'right') {\n      left = targetRect.right + arrowSpacing + scrollLeft;\n    } else {\n      left = targetRect.left - arrowSpacing - tip.offsetWidth + scrollLeft;\n    }\n  }\n\n  return {\n    left: left,\n    top: top,\n    transform: transform\n  };\n}\n/**\n * sets the Arrow styles based on direction\n */\n\n\nfunction getArrowStyles(target, tip, direction, state, props) {\n  if (!target || !props.arrow) {\n    return {\n      positionStyles: {\n        top: '0',\n        left: '-10000000px'\n      }\n    };\n  }\n\n  var targetRect = target.getBoundingClientRect();\n  var halfTargetHeight = Math.round(target.offsetHeight / 2);\n  var halfTargetWidth = Math.round(target.offsetWidth / 2);\n  var scrollTop = (0, _functions.getScrollTop)();\n  var scrollLeft = (0, _functions.getScrollLeft)();\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n  var borderStyles = {};\n  var positionStyles = {};\n\n  switch (direction) {\n    case 'right':\n      borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderBottom = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderRightWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderRightStyle = 'solid';\n      }\n\n      positionStyles.top = state.showTip && tip ? targetRect.top + scrollTop + halfTargetHeight - props.arrowSize : '-10000000px';\n      positionStyles.left = targetRect.right + scrollLeft + arrowSpacing - props.arrowSize;\n      break;\n\n    case 'left':\n      borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderBottom = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderLeftWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderLeftStyle = 'solid';\n      }\n\n      positionStyles.top = state.showTip && tip ? targetRect.top + scrollTop + halfTargetHeight - props.arrowSize : '-10000000px';\n      positionStyles.left = targetRect.left + scrollLeft - arrowSpacing - 1;\n      break;\n\n    case 'up':\n      borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid transparent\"); // if color is styled with css, we need everything except border-color, if styled with props, we add entire border rule\n\n      if (props.background) {\n        borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderTopWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderTopStyle = 'solid';\n      }\n\n      positionStyles.left = state.showTip && tip ? targetRect.left + scrollLeft + halfTargetWidth - props.arrowSize : '-10000000px';\n      positionStyles.top = targetRect.top + scrollTop - arrowSpacing;\n      break;\n\n    case 'down':\n    default:\n      borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderBottom = \"10px solid \".concat(props.background);\n      } else {\n        borderStyles.borderBottomWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderBottomStyle = 'solid';\n      }\n\n      positionStyles.left = state.showTip && tip ? targetRect.left + scrollLeft + halfTargetWidth - props.arrowSize : '-10000000px';\n      positionStyles.top = targetRect.bottom + scrollTop + arrowSpacing - props.arrowSize;\n      break;\n  }\n\n  return {\n    borderStyles: borderStyles,\n    positionStyles: positionStyles\n  };\n}\n/**\n * Returns the positions style rules\n */\n\n\nfunction positions(direction, forceDirection, tip, target, state, props) {\n  var alignMode = parseAlignMode(direction);\n  var trimmedDirection = direction.split('-')[0];\n  var realDirection = trimmedDirection;\n\n  if (!forceDirection && tip) {\n    var testArrowStyles = props.arrow && getArrowStyles(target, tip, trimmedDirection, state, props);\n    realDirection = (0, _getDirection[\"default\"])(trimmedDirection, tip, target, props, _functions.bodyPadding, testArrowStyles);\n  }\n\n  var maxWidth = getTipMaxWidth(); // force the tip to display the width we measured everything at when visible\n\n  var width;\n\n  if (tip) {\n    // adding the exact width on the first render forces a bogus line break, so add 1px the first time\n    var spacer = tip.style.width ? 0 : 1;\n    width = Math.min(tip.offsetWidth, maxWidth) + spacer;\n  }\n\n  var tipPosition = realDirection === 'up' || realDirection === 'down' ? getUpDownPosition(tip, target, state, realDirection, alignMode, props) : getLeftRightPosition(tip, target, state, realDirection, alignMode, props);\n  return {\n    tip: _objectSpread({}, tipPosition, {\n      maxWidth: maxWidth,\n      width: width\n    }),\n    arrow: getArrowStyles(target, tip, realDirection, state, props),\n    realDirection: realDirection\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","positions","_getDirection","_interopRequireDefault","require","_functions","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","configurable","writable","getTipMaxWidth","document","documentElement","clientWidth","bodyPadding","parseAlignMode","direction","directionArray","split","getUpDownPosition","tip","state","alignMode","props","left","top","transform","showTip","undefined","arrowSpacing","getArrowSpacing","scrollLeft","getScrollLeft","targetRect","getBoundingClientRect","targetLeft","halfTargetWidth","Math","round","offsetWidth","tipWidth","min","arrowCenter","arrowLeft","arrowSize","arrowRight","arrow","rightWithArrow","max","rightEdge","centeredLeft","availableSpaceOnLeft","rightOfTip","rightOfScreen","rightOverhang","getScrollTop","offsetHeight","bottom","getLeftRightPosition","arrowPadding","minArrowPadding","scrollTop","targetTop","halfTargetHeight","arrowTop","arrowBottom","topForBottomAlign","centeredTop","bottomOverhang","window","innerHeight","right","getArrowStyles","positionStyles","borderStyles","borderTop","borderBottom","background","borderRight","borderRightWidth","borderRightStyle","borderLeft","borderLeftWidth","borderLeftStyle","borderTopWidth","borderTopStyle","borderBottomWidth","borderBottomStyle","forceDirection","trimmedDirection","realDirection","testArrowStyles","maxWidth","width","spacer","style","tipPosition"],"sources":["/home/umang7/Music/Ripik-Website/node_modules/react-tooltip-lite/dist/position.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = positions;\n\nvar _getDirection = _interopRequireDefault(require(\"./getDirection\"));\n\nvar _functions = require(\"./functions\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Sets tip max width safely for mobile\n */\nfunction getTipMaxWidth() {\n  return typeof document !== 'undefined' ? document.documentElement.clientWidth - _functions.bodyPadding * 2 : 1000;\n}\n/**\n * Parses align mode from direction if specified with hyphen, defaulting to middle if not -\n * e.g. 'left-start' is mode 'start' and 'left' would be the default of 'middle'\n */\n\n\nfunction parseAlignMode(direction) {\n  var directionArray = direction.split('-');\n\n  if (directionArray.length > 1) {\n    return directionArray[1];\n  }\n\n  return 'middle';\n}\n/**\n * Gets wrapper's left position for top/bottom tooltips as well as needed width restriction\n */\n\n\nfunction getUpDownPosition(tip, target, state, direction, alignMode, props) {\n  var left = -10000000;\n  var top;\n  var transform = state.showTip ? undefined : 'translateX(-10000000px)';\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n\n  if (tip) {\n    // get wrapper left position\n    var scrollLeft = (0, _functions.getScrollLeft)();\n    var targetRect = target.getBoundingClientRect();\n    var targetLeft = targetRect.left + scrollLeft;\n    var halfTargetWidth = Math.round(target.offsetWidth / 2);\n    var tipWidth = Math.min(getTipMaxWidth(), tip.offsetWidth);\n    var arrowCenter = targetLeft + halfTargetWidth;\n    var arrowLeft = arrowCenter - props.arrowSize;\n    var arrowRight = arrowCenter + props.arrowSize;\n\n    if (alignMode === 'start') {\n      left = props.arrow ? Math.min(arrowLeft, targetLeft) : targetLeft;\n    } else if (alignMode === 'end') {\n      var rightWithArrow = Math.max(arrowRight, targetLeft + target.offsetWidth);\n      var rightEdge = props.arrow ? rightWithArrow : targetLeft + target.offsetWidth;\n      left = Math.max(rightEdge - tipWidth, _functions.bodyPadding + scrollLeft);\n    } else {\n      var centeredLeft = targetLeft + halfTargetWidth - Math.round(tipWidth / 2);\n      var availableSpaceOnLeft = _functions.bodyPadding + scrollLeft;\n      left = Math.max(centeredLeft, availableSpaceOnLeft);\n    } // check for right overhang\n\n\n    var rightOfTip = left + tipWidth;\n    var rightOfScreen = scrollLeft + document.documentElement.clientWidth - _functions.bodyPadding;\n    var rightOverhang = rightOfTip - rightOfScreen;\n\n    if (rightOverhang > 0) {\n      left -= rightOverhang;\n    }\n\n    if (direction === 'up') {\n      top = targetRect.top + (0, _functions.getScrollTop)() - (tip.offsetHeight + arrowSpacing);\n    } else {\n      top = targetRect.bottom + (0, _functions.getScrollTop)() + arrowSpacing;\n    }\n  }\n\n  return {\n    left: left,\n    top: top,\n    transform: transform\n  };\n}\n/**\n * gets top position for left/right arrows\n */\n\n\nfunction getLeftRightPosition(tip, target, state, direction, alignMode, props) {\n  var left = -10000000;\n  var top = 0;\n  var transform = state.showTip ? undefined : 'translateX(-10000000px)';\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n  var arrowPadding = props.arrow ? _functions.minArrowPadding : 0;\n\n  if (tip) {\n    var scrollTop = (0, _functions.getScrollTop)();\n    var scrollLeft = (0, _functions.getScrollLeft)();\n    var targetRect = target.getBoundingClientRect();\n    var targetTop = targetRect.top + scrollTop;\n    var halfTargetHeight = Math.round(target.offsetHeight / 2);\n    var arrowTop = targetTop + halfTargetHeight - props.arrowSize;\n    var arrowBottom = targetRect.top + scrollTop + halfTargetHeight + props.arrowSize; // TODO: handle close to edges better\n\n    if (alignMode === 'start') {\n      top = props.arrow ? Math.min(targetTop, arrowTop) : targetTop;\n    } else if (alignMode === 'end') {\n      var topForBottomAlign = targetRect.bottom + scrollTop - tip.offsetHeight;\n      top = props.arrow ? Math.max(topForBottomAlign, arrowBottom - tip.offsetHeight) : topForBottomAlign;\n    } else {\n      // default to middle, but don't go below body\n      var centeredTop = Math.max(targetTop + halfTargetHeight - Math.round(tip.offsetHeight / 2), _functions.bodyPadding + scrollTop); // make sure it doesn't go below the arrow\n\n      top = Math.min(centeredTop, arrowTop - arrowPadding);\n    } // check for bottom overhang\n\n\n    var bottomOverhang = top - scrollTop + tip.offsetHeight + _functions.bodyPadding - window.innerHeight;\n\n    if (bottomOverhang > 0) {\n      // try to add the body padding below the tip, but don't offset too far from the arrow\n      top = Math.max(top - bottomOverhang, arrowBottom + arrowPadding - tip.offsetHeight);\n    }\n\n    if (direction === 'right') {\n      left = targetRect.right + arrowSpacing + scrollLeft;\n    } else {\n      left = targetRect.left - arrowSpacing - tip.offsetWidth + scrollLeft;\n    }\n  }\n\n  return {\n    left: left,\n    top: top,\n    transform: transform\n  };\n}\n/**\n * sets the Arrow styles based on direction\n */\n\n\nfunction getArrowStyles(target, tip, direction, state, props) {\n  if (!target || !props.arrow) {\n    return {\n      positionStyles: {\n        top: '0',\n        left: '-10000000px'\n      }\n    };\n  }\n\n  var targetRect = target.getBoundingClientRect();\n  var halfTargetHeight = Math.round(target.offsetHeight / 2);\n  var halfTargetWidth = Math.round(target.offsetWidth / 2);\n  var scrollTop = (0, _functions.getScrollTop)();\n  var scrollLeft = (0, _functions.getScrollLeft)();\n  var arrowSpacing = (0, _functions.getArrowSpacing)(props);\n  var borderStyles = {};\n  var positionStyles = {};\n\n  switch (direction) {\n    case 'right':\n      borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderBottom = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderRightWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderRightStyle = 'solid';\n      }\n\n      positionStyles.top = state.showTip && tip ? targetRect.top + scrollTop + halfTargetHeight - props.arrowSize : '-10000000px';\n      positionStyles.left = targetRect.right + scrollLeft + arrowSpacing - props.arrowSize;\n      break;\n\n    case 'left':\n      borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderBottom = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderLeftWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderLeftStyle = 'solid';\n      }\n\n      positionStyles.top = state.showTip && tip ? targetRect.top + scrollTop + halfTargetHeight - props.arrowSize : '-10000000px';\n      positionStyles.left = targetRect.left + scrollLeft - arrowSpacing - 1;\n      break;\n\n    case 'up':\n      borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid transparent\"); // if color is styled with css, we need everything except border-color, if styled with props, we add entire border rule\n\n      if (props.background) {\n        borderStyles.borderTop = \"\".concat(props.arrowSize, \"px solid \").concat(props.background);\n      } else {\n        borderStyles.borderTopWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderTopStyle = 'solid';\n      }\n\n      positionStyles.left = state.showTip && tip ? targetRect.left + scrollLeft + halfTargetWidth - props.arrowSize : '-10000000px';\n      positionStyles.top = targetRect.top + scrollTop - arrowSpacing;\n      break;\n\n    case 'down':\n    default:\n      borderStyles.borderLeft = \"\".concat(props.arrowSize, \"px solid transparent\");\n      borderStyles.borderRight = \"\".concat(props.arrowSize, \"px solid transparent\");\n\n      if (props.background) {\n        borderStyles.borderBottom = \"10px solid \".concat(props.background);\n      } else {\n        borderStyles.borderBottomWidth = \"\".concat(props.arrowSize, \"px\");\n        borderStyles.borderBottomStyle = 'solid';\n      }\n\n      positionStyles.left = state.showTip && tip ? targetRect.left + scrollLeft + halfTargetWidth - props.arrowSize : '-10000000px';\n      positionStyles.top = targetRect.bottom + scrollTop + arrowSpacing - props.arrowSize;\n      break;\n  }\n\n  return {\n    borderStyles: borderStyles,\n    positionStyles: positionStyles\n  };\n}\n/**\n * Returns the positions style rules\n */\n\n\nfunction positions(direction, forceDirection, tip, target, state, props) {\n  var alignMode = parseAlignMode(direction);\n  var trimmedDirection = direction.split('-')[0];\n  var realDirection = trimmedDirection;\n\n  if (!forceDirection && tip) {\n    var testArrowStyles = props.arrow && getArrowStyles(target, tip, trimmedDirection, state, props);\n    realDirection = (0, _getDirection[\"default\"])(trimmedDirection, tip, target, props, _functions.bodyPadding, testArrowStyles);\n  }\n\n  var maxWidth = getTipMaxWidth(); // force the tip to display the width we measured everything at when visible\n\n  var width;\n\n  if (tip) {\n    // adding the exact width on the first render forces a bogus line break, so add 1px the first time\n    var spacer = tip.style.width ? 0 : 1;\n    width = Math.min(tip.offsetWidth, maxWidth) + spacer;\n  }\n\n  var tipPosition = realDirection === 'up' || realDirection === 'down' ? getUpDownPosition(tip, target, state, realDirection, alignMode, props) : getLeftRightPosition(tip, target, state, realDirection, alignMode, props);\n  return {\n    tip: _objectSpread({}, tipPosition, {\n      maxWidth: maxWidth,\n      width: width\n    }),\n    arrow: getArrowStyles(target, tip, realDirection, state, props),\n    realDirection: realDirection\n  };\n}"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAC3CC,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqBE,SAArB;;AAEA,IAAIC,aAAa,GAAGC,sBAAsB,CAACC,OAAO,CAAC,gBAAD,CAAR,CAA1C;;AAEA,IAAIC,UAAU,GAAGD,OAAO,CAAC,aAAD,CAAxB;;AAEA,SAASD,sBAAT,CAAgCG,GAAhC,EAAqC;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;IAAE,WAAWA;EAAb,CAArC;AAA0D;;AAEjG,SAASE,aAAT,CAAuBC,MAAvB,EAA+B;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;IAAE,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;IAAuD,IAAII,OAAO,GAAGjB,MAAM,CAACkB,IAAP,CAAYF,MAAZ,CAAd;;IAAmC,IAAI,OAAOhB,MAAM,CAACmB,qBAAd,KAAwC,UAA5C,EAAwD;MAAEF,OAAO,GAAGA,OAAO,CAACG,MAAR,CAAepB,MAAM,CAACmB,qBAAP,CAA6BH,MAA7B,EAAqCK,MAArC,CAA4C,UAAUC,GAAV,EAAe;QAAE,OAAOtB,MAAM,CAACuB,wBAAP,CAAgCP,MAAhC,EAAwCM,GAAxC,EAA6CE,UAApD;MAAiE,CAA9H,CAAf,CAAV;IAA4J;;IAACP,OAAO,CAACQ,OAAR,CAAgB,UAAUC,GAAV,EAAe;MAAEC,eAAe,CAACf,MAAD,EAASc,GAAT,EAAcV,MAAM,CAACU,GAAD,CAApB,CAAf;IAA4C,CAA7E;EAAiF;;EAAC,OAAOd,MAAP;AAAgB;;AAEje,SAASe,eAAT,CAAyBlB,GAAzB,EAA8BiB,GAA9B,EAAmCvB,KAAnC,EAA0C;EAAE,IAAIuB,GAAG,IAAIjB,GAAX,EAAgB;IAAET,MAAM,CAACC,cAAP,CAAsBQ,GAAtB,EAA2BiB,GAA3B,EAAgC;MAAEvB,KAAK,EAAEA,KAAT;MAAgBqB,UAAU,EAAE,IAA5B;MAAkCI,YAAY,EAAE,IAAhD;MAAsDC,QAAQ,EAAE;IAAhE,CAAhC;EAA0G,CAA5H,MAAkI;IAAEpB,GAAG,CAACiB,GAAD,CAAH,GAAWvB,KAAX;EAAmB;;EAAC,OAAOM,GAAP;AAAa;AAEjN;AACA;AACA;;;AACA,SAASqB,cAAT,GAA0B;EACxB,OAAO,OAAOC,QAAP,KAAoB,WAApB,GAAkCA,QAAQ,CAACC,eAAT,CAAyBC,WAAzB,GAAuCzB,UAAU,CAAC0B,WAAX,GAAyB,CAAlG,GAAsG,IAA7G;AACD;AACD;AACA;AACA;AACA;;;AAGA,SAASC,cAAT,CAAwBC,SAAxB,EAAmC;EACjC,IAAIC,cAAc,GAAGD,SAAS,CAACE,KAAV,CAAgB,GAAhB,CAArB;;EAEA,IAAID,cAAc,CAACtB,MAAf,GAAwB,CAA5B,EAA+B;IAC7B,OAAOsB,cAAc,CAAC,CAAD,CAArB;EACD;;EAED,OAAO,QAAP;AACD;AACD;AACA;AACA;;;AAGA,SAASE,iBAAT,CAA2BC,GAA3B,EAAgC5B,MAAhC,EAAwC6B,KAAxC,EAA+CL,SAA/C,EAA0DM,SAA1D,EAAqEC,KAArE,EAA4E;EAC1E,IAAIC,IAAI,GAAG,CAAC,QAAZ;EACA,IAAIC,GAAJ;EACA,IAAIC,SAAS,GAAGL,KAAK,CAACM,OAAN,GAAgBC,SAAhB,GAA4B,yBAA5C;EACA,IAAIC,YAAY,GAAG,CAAC,GAAGzC,UAAU,CAAC0C,eAAf,EAAgCP,KAAhC,CAAnB;;EAEA,IAAIH,GAAJ,EAAS;IACP;IACA,IAAIW,UAAU,GAAG,CAAC,GAAG3C,UAAU,CAAC4C,aAAf,GAAjB;IACA,IAAIC,UAAU,GAAGzC,MAAM,CAAC0C,qBAAP,EAAjB;IACA,IAAIC,UAAU,GAAGF,UAAU,CAACT,IAAX,GAAkBO,UAAnC;IACA,IAAIK,eAAe,GAAGC,IAAI,CAACC,KAAL,CAAW9C,MAAM,CAAC+C,WAAP,GAAqB,CAAhC,CAAtB;IACA,IAAIC,QAAQ,GAAGH,IAAI,CAACI,GAAL,CAAS/B,cAAc,EAAvB,EAA2BU,GAAG,CAACmB,WAA/B,CAAf;IACA,IAAIG,WAAW,GAAGP,UAAU,GAAGC,eAA/B;IACA,IAAIO,SAAS,GAAGD,WAAW,GAAGnB,KAAK,CAACqB,SAApC;IACA,IAAIC,UAAU,GAAGH,WAAW,GAAGnB,KAAK,CAACqB,SAArC;;IAEA,IAAItB,SAAS,KAAK,OAAlB,EAA2B;MACzBE,IAAI,GAAGD,KAAK,CAACuB,KAAN,GAAcT,IAAI,CAACI,GAAL,CAASE,SAAT,EAAoBR,UAApB,CAAd,GAAgDA,UAAvD;IACD,CAFD,MAEO,IAAIb,SAAS,KAAK,KAAlB,EAAyB;MAC9B,IAAIyB,cAAc,GAAGV,IAAI,CAACW,GAAL,CAASH,UAAT,EAAqBV,UAAU,GAAG3C,MAAM,CAAC+C,WAAzC,CAArB;MACA,IAAIU,SAAS,GAAG1B,KAAK,CAACuB,KAAN,GAAcC,cAAd,GAA+BZ,UAAU,GAAG3C,MAAM,CAAC+C,WAAnE;MACAf,IAAI,GAAGa,IAAI,CAACW,GAAL,CAASC,SAAS,GAAGT,QAArB,EAA+BpD,UAAU,CAAC0B,WAAX,GAAyBiB,UAAxD,CAAP;IACD,CAJM,MAIA;MACL,IAAImB,YAAY,GAAGf,UAAU,GAAGC,eAAb,GAA+BC,IAAI,CAACC,KAAL,CAAWE,QAAQ,GAAG,CAAtB,CAAlD;MACA,IAAIW,oBAAoB,GAAG/D,UAAU,CAAC0B,WAAX,GAAyBiB,UAApD;MACAP,IAAI,GAAGa,IAAI,CAACW,GAAL,CAASE,YAAT,EAAuBC,oBAAvB,CAAP;IACD,CArBM,CAqBL;;;IAGF,IAAIC,UAAU,GAAG5B,IAAI,GAAGgB,QAAxB;IACA,IAAIa,aAAa,GAAGtB,UAAU,GAAGpB,QAAQ,CAACC,eAAT,CAAyBC,WAAtC,GAAoDzB,UAAU,CAAC0B,WAAnF;IACA,IAAIwC,aAAa,GAAGF,UAAU,GAAGC,aAAjC;;IAEA,IAAIC,aAAa,GAAG,CAApB,EAAuB;MACrB9B,IAAI,IAAI8B,aAAR;IACD;;IAED,IAAItC,SAAS,KAAK,IAAlB,EAAwB;MACtBS,GAAG,GAAGQ,UAAU,CAACR,GAAX,GAAiB,CAAC,GAAGrC,UAAU,CAACmE,YAAf,GAAjB,IAAmDnC,GAAG,CAACoC,YAAJ,GAAmB3B,YAAtE,CAAN;IACD,CAFD,MAEO;MACLJ,GAAG,GAAGQ,UAAU,CAACwB,MAAX,GAAoB,CAAC,GAAGrE,UAAU,CAACmE,YAAf,GAApB,GAAqD1B,YAA3D;IACD;EACF;;EAED,OAAO;IACLL,IAAI,EAAEA,IADD;IAELC,GAAG,EAAEA,GAFA;IAGLC,SAAS,EAAEA;EAHN,CAAP;AAKD;AACD;AACA;AACA;;;AAGA,SAASgC,oBAAT,CAA8BtC,GAA9B,EAAmC5B,MAAnC,EAA2C6B,KAA3C,EAAkDL,SAAlD,EAA6DM,SAA7D,EAAwEC,KAAxE,EAA+E;EAC7E,IAAIC,IAAI,GAAG,CAAC,QAAZ;EACA,IAAIC,GAAG,GAAG,CAAV;EACA,IAAIC,SAAS,GAAGL,KAAK,CAACM,OAAN,GAAgBC,SAAhB,GAA4B,yBAA5C;EACA,IAAIC,YAAY,GAAG,CAAC,GAAGzC,UAAU,CAAC0C,eAAf,EAAgCP,KAAhC,CAAnB;EACA,IAAIoC,YAAY,GAAGpC,KAAK,CAACuB,KAAN,GAAc1D,UAAU,CAACwE,eAAzB,GAA2C,CAA9D;;EAEA,IAAIxC,GAAJ,EAAS;IACP,IAAIyC,SAAS,GAAG,CAAC,GAAGzE,UAAU,CAACmE,YAAf,GAAhB;IACA,IAAIxB,UAAU,GAAG,CAAC,GAAG3C,UAAU,CAAC4C,aAAf,GAAjB;IACA,IAAIC,UAAU,GAAGzC,MAAM,CAAC0C,qBAAP,EAAjB;IACA,IAAI4B,SAAS,GAAG7B,UAAU,CAACR,GAAX,GAAiBoC,SAAjC;IACA,IAAIE,gBAAgB,GAAG1B,IAAI,CAACC,KAAL,CAAW9C,MAAM,CAACgE,YAAP,GAAsB,CAAjC,CAAvB;IACA,IAAIQ,QAAQ,GAAGF,SAAS,GAAGC,gBAAZ,GAA+BxC,KAAK,CAACqB,SAApD;IACA,IAAIqB,WAAW,GAAGhC,UAAU,CAACR,GAAX,GAAiBoC,SAAjB,GAA6BE,gBAA7B,GAAgDxC,KAAK,CAACqB,SAAxE,CAPO,CAO4E;;IAEnF,IAAItB,SAAS,KAAK,OAAlB,EAA2B;MACzBG,GAAG,GAAGF,KAAK,CAACuB,KAAN,GAAcT,IAAI,CAACI,GAAL,CAASqB,SAAT,EAAoBE,QAApB,CAAd,GAA8CF,SAApD;IACD,CAFD,MAEO,IAAIxC,SAAS,KAAK,KAAlB,EAAyB;MAC9B,IAAI4C,iBAAiB,GAAGjC,UAAU,CAACwB,MAAX,GAAoBI,SAApB,GAAgCzC,GAAG,CAACoC,YAA5D;MACA/B,GAAG,GAAGF,KAAK,CAACuB,KAAN,GAAcT,IAAI,CAACW,GAAL,CAASkB,iBAAT,EAA4BD,WAAW,GAAG7C,GAAG,CAACoC,YAA9C,CAAd,GAA4EU,iBAAlF;IACD,CAHM,MAGA;MACL;MACA,IAAIC,WAAW,GAAG9B,IAAI,CAACW,GAAL,CAASc,SAAS,GAAGC,gBAAZ,GAA+B1B,IAAI,CAACC,KAAL,CAAWlB,GAAG,CAACoC,YAAJ,GAAmB,CAA9B,CAAxC,EAA0EpE,UAAU,CAAC0B,WAAX,GAAyB+C,SAAnG,CAAlB,CAFK,CAE4H;;MAEjIpC,GAAG,GAAGY,IAAI,CAACI,GAAL,CAAS0B,WAAT,EAAsBH,QAAQ,GAAGL,YAAjC,CAAN;IACD,CAnBM,CAmBL;;;IAGF,IAAIS,cAAc,GAAG3C,GAAG,GAAGoC,SAAN,GAAkBzC,GAAG,CAACoC,YAAtB,GAAqCpE,UAAU,CAAC0B,WAAhD,GAA8DuD,MAAM,CAACC,WAA1F;;IAEA,IAAIF,cAAc,GAAG,CAArB,EAAwB;MACtB;MACA3C,GAAG,GAAGY,IAAI,CAACW,GAAL,CAASvB,GAAG,GAAG2C,cAAf,EAA+BH,WAAW,GAAGN,YAAd,GAA6BvC,GAAG,CAACoC,YAAhE,CAAN;IACD;;IAED,IAAIxC,SAAS,KAAK,OAAlB,EAA2B;MACzBQ,IAAI,GAAGS,UAAU,CAACsC,KAAX,GAAmB1C,YAAnB,GAAkCE,UAAzC;IACD,CAFD,MAEO;MACLP,IAAI,GAAGS,UAAU,CAACT,IAAX,GAAkBK,YAAlB,GAAiCT,GAAG,CAACmB,WAArC,GAAmDR,UAA1D;IACD;EACF;;EAED,OAAO;IACLP,IAAI,EAAEA,IADD;IAELC,GAAG,EAAEA,GAFA;IAGLC,SAAS,EAAEA;EAHN,CAAP;AAKD;AACD;AACA;AACA;;;AAGA,SAAS8C,cAAT,CAAwBhF,MAAxB,EAAgC4B,GAAhC,EAAqCJ,SAArC,EAAgDK,KAAhD,EAAuDE,KAAvD,EAA8D;EAC5D,IAAI,CAAC/B,MAAD,IAAW,CAAC+B,KAAK,CAACuB,KAAtB,EAA6B;IAC3B,OAAO;MACL2B,cAAc,EAAE;QACdhD,GAAG,EAAE,GADS;QAEdD,IAAI,EAAE;MAFQ;IADX,CAAP;EAMD;;EAED,IAAIS,UAAU,GAAGzC,MAAM,CAAC0C,qBAAP,EAAjB;EACA,IAAI6B,gBAAgB,GAAG1B,IAAI,CAACC,KAAL,CAAW9C,MAAM,CAACgE,YAAP,GAAsB,CAAjC,CAAvB;EACA,IAAIpB,eAAe,GAAGC,IAAI,CAACC,KAAL,CAAW9C,MAAM,CAAC+C,WAAP,GAAqB,CAAhC,CAAtB;EACA,IAAIsB,SAAS,GAAG,CAAC,GAAGzE,UAAU,CAACmE,YAAf,GAAhB;EACA,IAAIxB,UAAU,GAAG,CAAC,GAAG3C,UAAU,CAAC4C,aAAf,GAAjB;EACA,IAAIH,YAAY,GAAG,CAAC,GAAGzC,UAAU,CAAC0C,eAAf,EAAgCP,KAAhC,CAAnB;EACA,IAAImD,YAAY,GAAG,EAAnB;EACA,IAAID,cAAc,GAAG,EAArB;;EAEA,QAAQzD,SAAR;IACE,KAAK,OAAL;MACE0D,YAAY,CAACC,SAAb,GAAyB,GAAG3E,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,sBAA3B,CAAzB;MACA8B,YAAY,CAACE,YAAb,GAA4B,GAAG5E,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,sBAA3B,CAA5B;;MAEA,IAAIrB,KAAK,CAACsD,UAAV,EAAsB;QACpBH,YAAY,CAACI,WAAb,GAA2B,GAAG9E,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,WAA3B,EAAwC5C,MAAxC,CAA+CuB,KAAK,CAACsD,UAArD,CAA3B;MACD,CAFD,MAEO;QACLH,YAAY,CAACK,gBAAb,GAAgC,GAAG/E,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,IAA3B,CAAhC;QACA8B,YAAY,CAACM,gBAAb,GAAgC,OAAhC;MACD;;MAEDP,cAAc,CAAChD,GAAf,GAAqBJ,KAAK,CAACM,OAAN,IAAiBP,GAAjB,GAAuBa,UAAU,CAACR,GAAX,GAAiBoC,SAAjB,GAA6BE,gBAA7B,GAAgDxC,KAAK,CAACqB,SAA7E,GAAyF,aAA9G;MACA6B,cAAc,CAACjD,IAAf,GAAsBS,UAAU,CAACsC,KAAX,GAAmBxC,UAAnB,GAAgCF,YAAhC,GAA+CN,KAAK,CAACqB,SAA3E;MACA;;IAEF,KAAK,MAAL;MACE8B,YAAY,CAACC,SAAb,GAAyB,GAAG3E,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,sBAA3B,CAAzB;MACA8B,YAAY,CAACE,YAAb,GAA4B,GAAG5E,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,sBAA3B,CAA5B;;MAEA,IAAIrB,KAAK,CAACsD,UAAV,EAAsB;QACpBH,YAAY,CAACO,UAAb,GAA0B,GAAGjF,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,WAA3B,EAAwC5C,MAAxC,CAA+CuB,KAAK,CAACsD,UAArD,CAA1B;MACD,CAFD,MAEO;QACLH,YAAY,CAACQ,eAAb,GAA+B,GAAGlF,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,IAA3B,CAA/B;QACA8B,YAAY,CAACS,eAAb,GAA+B,OAA/B;MACD;;MAEDV,cAAc,CAAChD,GAAf,GAAqBJ,KAAK,CAACM,OAAN,IAAiBP,GAAjB,GAAuBa,UAAU,CAACR,GAAX,GAAiBoC,SAAjB,GAA6BE,gBAA7B,GAAgDxC,KAAK,CAACqB,SAA7E,GAAyF,aAA9G;MACA6B,cAAc,CAACjD,IAAf,GAAsBS,UAAU,CAACT,IAAX,GAAkBO,UAAlB,GAA+BF,YAA/B,GAA8C,CAApE;MACA;;IAEF,KAAK,IAAL;MACE6C,YAAY,CAACO,UAAb,GAA0B,GAAGjF,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,sBAA3B,CAA1B;MACA8B,YAAY,CAACI,WAAb,GAA2B,GAAG9E,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,sBAA3B,CAA3B,CAFF,CAEiF;;MAE/E,IAAIrB,KAAK,CAACsD,UAAV,EAAsB;QACpBH,YAAY,CAACC,SAAb,GAAyB,GAAG3E,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,WAA3B,EAAwC5C,MAAxC,CAA+CuB,KAAK,CAACsD,UAArD,CAAzB;MACD,CAFD,MAEO;QACLH,YAAY,CAACU,cAAb,GAA8B,GAAGpF,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,IAA3B,CAA9B;QACA8B,YAAY,CAACW,cAAb,GAA8B,OAA9B;MACD;;MAEDZ,cAAc,CAACjD,IAAf,GAAsBH,KAAK,CAACM,OAAN,IAAiBP,GAAjB,GAAuBa,UAAU,CAACT,IAAX,GAAkBO,UAAlB,GAA+BK,eAA/B,GAAiDb,KAAK,CAACqB,SAA9E,GAA0F,aAAhH;MACA6B,cAAc,CAAChD,GAAf,GAAqBQ,UAAU,CAACR,GAAX,GAAiBoC,SAAjB,GAA6BhC,YAAlD;MACA;;IAEF,KAAK,MAAL;IACA;MACE6C,YAAY,CAACO,UAAb,GAA0B,GAAGjF,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,sBAA3B,CAA1B;MACA8B,YAAY,CAACI,WAAb,GAA2B,GAAG9E,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,sBAA3B,CAA3B;;MAEA,IAAIrB,KAAK,CAACsD,UAAV,EAAsB;QACpBH,YAAY,CAACE,YAAb,GAA4B,cAAc5E,MAAd,CAAqBuB,KAAK,CAACsD,UAA3B,CAA5B;MACD,CAFD,MAEO;QACLH,YAAY,CAACY,iBAAb,GAAiC,GAAGtF,MAAH,CAAUuB,KAAK,CAACqB,SAAhB,EAA2B,IAA3B,CAAjC;QACA8B,YAAY,CAACa,iBAAb,GAAiC,OAAjC;MACD;;MAEDd,cAAc,CAACjD,IAAf,GAAsBH,KAAK,CAACM,OAAN,IAAiBP,GAAjB,GAAuBa,UAAU,CAACT,IAAX,GAAkBO,UAAlB,GAA+BK,eAA/B,GAAiDb,KAAK,CAACqB,SAA9E,GAA0F,aAAhH;MACA6B,cAAc,CAAChD,GAAf,GAAqBQ,UAAU,CAACwB,MAAX,GAAoBI,SAApB,GAAgChC,YAAhC,GAA+CN,KAAK,CAACqB,SAA1E;MACA;EA5DJ;;EA+DA,OAAO;IACL8B,YAAY,EAAEA,YADT;IAELD,cAAc,EAAEA;EAFX,CAAP;AAID;AACD;AACA;AACA;;;AAGA,SAASzF,SAAT,CAAmBgC,SAAnB,EAA8BwE,cAA9B,EAA8CpE,GAA9C,EAAmD5B,MAAnD,EAA2D6B,KAA3D,EAAkEE,KAAlE,EAAyE;EACvE,IAAID,SAAS,GAAGP,cAAc,CAACC,SAAD,CAA9B;EACA,IAAIyE,gBAAgB,GAAGzE,SAAS,CAACE,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAvB;EACA,IAAIwE,aAAa,GAAGD,gBAApB;;EAEA,IAAI,CAACD,cAAD,IAAmBpE,GAAvB,EAA4B;IAC1B,IAAIuE,eAAe,GAAGpE,KAAK,CAACuB,KAAN,IAAe0B,cAAc,CAAChF,MAAD,EAAS4B,GAAT,EAAcqE,gBAAd,EAAgCpE,KAAhC,EAAuCE,KAAvC,CAAnD;IACAmE,aAAa,GAAG,CAAC,GAAGzG,aAAa,CAAC,SAAD,CAAjB,EAA8BwG,gBAA9B,EAAgDrE,GAAhD,EAAqD5B,MAArD,EAA6D+B,KAA7D,EAAoEnC,UAAU,CAAC0B,WAA/E,EAA4F6E,eAA5F,CAAhB;EACD;;EAED,IAAIC,QAAQ,GAAGlF,cAAc,EAA7B,CAVuE,CAUtC;;EAEjC,IAAImF,KAAJ;;EAEA,IAAIzE,GAAJ,EAAS;IACP;IACA,IAAI0E,MAAM,GAAG1E,GAAG,CAAC2E,KAAJ,CAAUF,KAAV,GAAkB,CAAlB,GAAsB,CAAnC;IACAA,KAAK,GAAGxD,IAAI,CAACI,GAAL,CAASrB,GAAG,CAACmB,WAAb,EAA0BqD,QAA1B,IAAsCE,MAA9C;EACD;;EAED,IAAIE,WAAW,GAAGN,aAAa,KAAK,IAAlB,IAA0BA,aAAa,KAAK,MAA5C,GAAqDvE,iBAAiB,CAACC,GAAD,EAAM5B,MAAN,EAAc6B,KAAd,EAAqBqE,aAArB,EAAoCpE,SAApC,EAA+CC,KAA/C,CAAtE,GAA8HmC,oBAAoB,CAACtC,GAAD,EAAM5B,MAAN,EAAc6B,KAAd,EAAqBqE,aAArB,EAAoCpE,SAApC,EAA+CC,KAA/C,CAApK;EACA,OAAO;IACLH,GAAG,EAAE7B,aAAa,CAAC,EAAD,EAAKyG,WAAL,EAAkB;MAClCJ,QAAQ,EAAEA,QADwB;MAElCC,KAAK,EAAEA;IAF2B,CAAlB,CADb;IAKL/C,KAAK,EAAE0B,cAAc,CAAChF,MAAD,EAAS4B,GAAT,EAAcsE,aAAd,EAA6BrE,KAA7B,EAAoCE,KAApC,CALhB;IAMLmE,aAAa,EAAEA;EANV,CAAP;AAQD"},"metadata":{},"sourceType":"script"}